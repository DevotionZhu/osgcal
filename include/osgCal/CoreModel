/* -*- c++ -*-
    Copyright (C) 2003 <ryu@gpul.org>
    Copyright (C) 2006 Vladimir Shabanov <vshabanoff@gmail.com>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
#ifndef __OSGCAL__CORE_MODEL_H__
#define __OSGCAL__CORE_MODEL_H__

#include <vector>
#include <map>
#include <stdexcept>
#include <memory>

#include <cal3d/cal3d.h>

#include <osg/Texture2D>
#include <osg/Referenced>
#include <osg/Material>
#include <osg/Program>
#include <osg/BufferObject>
#include <osgCal/Export>

#include <osgDB/ReaderWriter>

#include <osgCal/IOUtils>

namespace osgCal
{
    // -- STATE SHARING PART --
    
    /**
     * Abstract base cache class.
     * To maximize state sharing we use separate caches for
     * osg::Material, osg::Texture2D, osg::StateSet (texturing only) and osg::StateSet (material and texturing).
     * There is also a separate cache for osg::StateSet with skeletal vertex shader added.
     *
     * Here is an internal cache hierarchy (the keys are shown in brakets):
     *
     * HardwareMeshStateSetCache[HwStateDesc]
     *  |- SoftwareMeshStateSetCache[SwStateDesc]
     *  \---|- TexturesCache[TextureDesc]
     *      \- MaterialsCache[MaterialDesc]
     */

    // -- Cache keys --
   
    /// CalCoreMaterial, osg::Material cache key
    class OSGCAL_EXPORT MaterialDesc
    {
        public:
            osg::Vec4      ambientColor;
            osg::Vec4      diffuseColor;
            osg::Vec4      specularColor;
            float          glossiness;

            MaterialDesc()
                : glossiness( 0 )
            {}

            /**
             * Setup material using core material and glossiness &
             * shininess.
             * There is a trouble with exporter, shininess value is
             * actually a specularColor strength and actual shininess
             * (which named as `glossiness' in 3DSMax) doesn't
             * exported at all.
             */
            MaterialDesc( CalCoreMaterial* ccm,
                          float glossiness,
                          float opacity );
    };

    /// Textures cache key (file name with full path)
    typedef std::string TextureDesc;

    /// Software mesh state set cache key
    class OSGCAL_EXPORT SwStateDesc
    {
        public:
            MaterialDesc material;
            TextureDesc  diffuseMap;

            /**
             * Number of sides for mesh.
             * 0 -- undefined (use default OSG culling);
             * 1 -- one side (backface culling);
             * 2 -- two sides (no culling for sw mesh and gl_FronFacing
             * hw mesh, or culling for hw mesh when gl_FronFacing is
             * not supported (using two pass with `face' uniform set
             * to 1, then -1 + frontface culling)
             */
            int          sides;

            SwStateDesc()
                : sides( 0 )
            {}
    };

    /// Hardware mesh state set cache key
    class OSGCAL_EXPORT HwStateDesc : public SwStateDesc
    {
        public:
            TextureDesc  normalsMap;
            TextureDesc  bumpMap; /// currently not supported
            float        normalsMapAmount; /// currently not supported
            float        bumpMapAmount; /// currently not supported
            int          shaderFlags; /// to determine, which shader
                                      /// program will be taken from
                                      /// shader program chache.

            HwStateDesc()
                : normalsMapAmount( 0 )
                , bumpMapAmount( 0 )
                , shaderFlags( 0 )
            {}

            /**
             * Create whole state description from cal3d material and
             * its maps.
             */
            HwStateDesc( CalCoreMaterial* m,
                         const std::string& dir = std::string() );
    };

    // -- Some utility --

    OSGCAL_EXPORT bool operator < ( const MaterialDesc& md1,
                                    const MaterialDesc& md2 );

    OSGCAL_EXPORT bool operator < ( const SwStateDesc& d1,
                                    const SwStateDesc& d2 );

    OSGCAL_EXPORT bool operator < ( const HwStateDesc& d1,
                                    const HwStateDesc& d2 );


    // -- Caches itself --
    class MaterialsCache : public osg::Referenced
    {
        public:
            osg::Material* get( const MaterialDesc& md );

        private:
            typedef std::map< MaterialDesc, osg::ref_ptr< osg::Material > > Map;
            Map cache;

            osg::Material* createMaterial( const MaterialDesc& desc );
    };

    class TexturesCache : public osg::Referenced
    {
        public:
            osg::Texture2D* get( const TextureDesc& td );

        private:
            typedef std::map< TextureDesc, osg::ref_ptr< osg::Texture2D > > Map;
            Map cache;
            
            osg::Texture2D* createTexture( const TextureDesc& fileName )
                throw (std::runtime_error);
    };

    class SwMeshStateSetCache : public osg::Referenced
    {
        public:
            SwMeshStateSetCache( MaterialsCache* mc = 0,
                                 TexturesCache* tc = 0 );
            
            osg::StateSet* get( const SwStateDesc& swsd );

        private:
            typedef std::map< SwStateDesc, osg::ref_ptr< osg::StateSet > > Map;

            Map cache;
            osg::ref_ptr< MaterialsCache > materialsCache;
            osg::ref_ptr< TexturesCache >  texturesCache;

            osg::StateSet* createSwMeshStateSet( const SwStateDesc& swsd );
    };

    class HwMeshStateSetCache : public osg::Referenced
    {
        public:
            HwMeshStateSetCache( SwMeshStateSetCache* swssc = 0,
                                 TexturesCache* tc = 0 );
            
            osg::StateSet* get( const HwStateDesc& swsd );

            int flags;

        private:
            typedef std::map< HwStateDesc, osg::ref_ptr< osg::StateSet > > Map;

            Map cache;
            osg::ref_ptr< SwMeshStateSetCache > swMeshStateSetCache;
            osg::ref_ptr< TexturesCache >       texturesCache;

            osg::StateSet* createHwMeshStateSet( const HwStateDesc& swsd );
    };

    class DepthMeshStateSetCache : public osg::Referenced
    {
        public:
            osg::StateSet* get( const HwStateDesc& swsd );

            int flags;

        private:
            // map from < bone count, sides count > to stateset
            typedef std::map< std::pair< int, int >, osg::ref_ptr< osg::StateSet > > Map;

            Map cache;

            osg::StateSet* createDepthMeshStateSet( const std::pair< int, int >& boneAndSidesCount );
    };
    
    // -- CORE MODEL CLASS --

    /**
     * Core Model class that creates a templated core object.
     * In order to create an animated model, a cal3d core model has to
     * be created. Given this core model it is possible to instantiate it
     * by creating a model which is in fact the real animated model and
     * object which can be inserted into an osg graph.
     */
    class OSGCAL_EXPORT CoreModel: public osg::Object
    {
        public:
            META_Object(osgCal, CoreModel);

            CoreModel();

            enum LoadFlags
            {
                /**
                 * No double draw of two-sided meshes use
                 * gl_FrontFacing in shader.
                 * Remark that not all video boards support this
                 * (GeForce >= 6.x, ATI -- don't know)
                 */
                USE_GL_FRONT_FACING = 0x1,

                /**
                 * Draw meshes to depth buffer first, then draw meshes
                 * with pixel shaders (useful if pixel shading is a
                 * bottleneck).
                 */
                USE_DEPTH_FIRST_MESHES = 0x2,

                /**
                 * Don't keep normals and texture coords for
                 * software meshes (free them after VBOs are applied).
                 */
                NO_SOFTWARE_MESHES = 0x8, // TODO: does not free memory yet

                /**
                 * Show Tangent-Binormal-Normal basis.
                 */
                SHOW_TBN = 0x10, // TODO: restore it

                /**
                 * Enable fog in shader (exp, exp2 or linear mode)
                 */
                FOG_EXP = 0x20,
                FOG_EXP2 = 0x40,
                FOG_LINEAR = 0x20 + 0x40,
            };

            /**
             * Loads cal3d core model and prepare all internal stuff for fast Models creation.
             * This function may be called only once.
             */
            void load( const std::string& cfgFileName,
                       int flags = 0 ) throw (std::runtime_error);

            /**
             * Same as load, but doesn't throw exceptions on error.
             */
            bool loadNoThrow( const std::string& cfgFileName,
                              std::string&       errorText,
                              int                flags = 0 ) throw ();

            CalCoreModel* getCalCoreModel() const  { return calCoreModel; }

            int           getFlags()        const  { return flags; }

            struct Mesh : public osg::Referenced
            {
                public:

                    osg::ref_ptr< MeshData >            data;

                    HwStateDesc                         hwStateDesc;

                    /**
                     * Mesh state set. Contain material, textures and also
                     * vertex program when mesh is hardware (hardwareMesh != 0).
                     */
                    osg::ref_ptr< osg::StateSet >       hardwareStateSet;
                    osg::ref_ptr< osg::StateSet >       staticHardwareStateSet; ///< zero bones state set
                    osg::ref_ptr< osg::StateSet >       stateSet;

                    osg::ref_ptr< osg::StateSet >       depthStateSet; ///< depth only hw state ste
                    osg::ref_ptr< osg::StateSet >       staticDepthStateSet; ///< zero bones state set
            };

            float getScale() const { return scale; }

            typedef std::vector< osg::ref_ptr< Mesh > > MeshVector;
            
            const MeshVector&                   getMeshes()         const { return meshes; }
            const std::vector< std::string >&   getAnimationNames() const { return animationNames; }

        private:

            CoreModel(const CoreModel&, const osg::CopyOp& copyop=osg::CopyOp::SHALLOW_COPY);
            virtual ~CoreModel();

            int                 flags;
            float               scale;
            CalCoreModel*       calCoreModel;

            TexturesCache*              texturesCache;
            SwMeshStateSetCache*        swMeshStateSetCache;
            HwMeshStateSetCache*        hwMeshStateSetCache;
            DepthMeshStateSetCache*     depthMeshStateSetCache;

            MeshVector                  meshes;
            std::vector< std::string >  animationNames;
    };

}; // namespace osgCal

#endif
