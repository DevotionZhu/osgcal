/* -*- c++ -*-
    Copyright (C) 2006 Vladimir Shabanov <vshabanoff@gmail.com>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
#ifndef __OSGCAL__IOUTILS_H__
#define __OSGCAL__IOUTILS_H__

#include <stdexcept>

#include <cal3d/cal3d.h>

#include <osgCal/Export>
#include <osg/Array>
#include <osg/PrimitiveSet>
#include <osg/BoundingBox>

namespace osgCal
{

    // -- Some string utilities (used in material map names) --
    
    /**
     * Return "prefix" from "prefix:foo:bar/baz" or empty string
     * when no ':' found.
     */
    std::string getPrefix( const std::string& str );

    /**
     * Return "suffix" from "foo:bar/baz:suffix" or whole string
     * when no ':' found.
     */
    std::string getSuffix( const std::string& str );

    std::string getAfter( const std::string& prefix,
                          const std::string& str );

    bool prefixEquals( const std::string& str,
                       const std::string& prefix );

    bool endsWith( const std::string& str,
                   const std::string& suffix );


    // -- Some other utilities --
    
    OSGCAL_EXPORT bool isFileExists( const std::string& f );


    // -- Vertex buffer objects & I/O --
#define OSGCAL_MAX_BONES_PER_MESH       30
#define OSGCAL_MAX_VERTEX_PER_MODEL     1000000

    typedef osg::Vec3Array      VertexBuffer;
    typedef osg::Vec4Array      WeightBuffer;
    // TODO: weight & matrixIndex dependent from bones count?
    typedef osg::Vec2Array      TexCoordBuffer;

    typedef osg::Vec4ubArray    MatrixIndexBuffer;

    /**
     * Index buffer may be DrawElementsUByte/UShort/UInt depending
     * from indexes count.
     */
    typedef osg::PrimitiveSet   IndexBuffer;

#ifdef OSG_CAL_BYTE_BUFFERS
    typedef osg::Vec3bArray     NormalBuffer;
    typedef osg::Vec4bArray     TangentAndHandednessBuffer;
    // byte is not supported by setTexCoordPointer,
    // but supported in setNormalPointer
#else
    typedef osg::Vec3Array      NormalBuffer;
    typedef osg::Vec4Array      TangentAndHandednessBuffer;
//    typedef osg::Vec4sArray     TangentAndHandednessBuffer;
#endif

    // -- Mesh data --

    /**
     * Mesh data that is loaded from external file or created using
     * CalHardwareModel. This structure contains geometry part of
     * mesh and material pointer. State sets and display lists are
     * managed in Model/CoreModel.
     */
    struct MeshData : public osg::Referenced
    {
        public:

            MeshData()
                : coreMaterial( 0 )
                , rigid( false )
                , rigidBoneId( -1 )
                , maxBonesInfluence( 0 )
            {}

            /**
             * Mesh name, may duplicate since for one source
             * CalCoreMesh there can be more than one hardware mesh.
             */
            std::string                   name;

            CalCoreMaterial*              coreMaterial;

            /**
             * Is mesh rigid?
             * Mesh is rigid when all its vertices are
             * rigged to one bone with weight = 1.0,
             * or when no one vertex is rigged at all.
             */
            bool                          rigid;

            /**
             * Rigid mesh bone id, or -1 when mesh is not rigged at all.
             */
            int                           rigidBoneId;

            /**
             * Max influencing bones used to select shader. Zero for
             * rigid meshes.
             */
            int                           maxBonesInfluence;
            
            /**
             * Map between indices in matrix index buffer and indices
             * of bones in CalSkeleton, exists only for non-rigid meshes
             */
            std::vector< int >            bonesIndices;

            /**
             * Bounding box in non-deformed state.
             */
            osg::BoundingBox              boundingBox;

            /**
             * DrawElementsUInt osg::PrimitiveSet is used as index
             * buffer to share it between meshes and use for picking.
             */
            osg::ref_ptr< IndexBuffer >                 indexBuffer;
            osg::ref_ptr< VertexBuffer >                vertexBuffer;

            /**
             * weight and matrixIndex buffers exists only for
             * non-rigid meshes.
             */
            osg::ref_ptr< WeightBuffer >                weightBuffer;
            osg::ref_ptr< MatrixIndexBuffer >           matrixIndexBuffer;

            osg::ref_ptr< NormalBuffer >                normalBuffer;

            /**
             * texCoordBuffer & tangentAndHandednessBuffer exists only
             * for meshes with 
             */
            osg::ref_ptr< TexCoordBuffer >              texCoordBuffer;
            osg::ref_ptr< TangentAndHandednessBuffer >  tangentAndHandednessBuffer;

            int getIndicesCount() const { return indexBuffer->getNumIndices(); }

            int getBonesCount() const { return bonesIndices.size(); }
            int getBoneId( int index ) const { return bonesIndices[ index ]; }
            CalBone* getBone( int index,
                              CalSkeleton* skeleton ) const
            {
                const std::vector< CalBone* >& vectorBone = skeleton->getVectorBone();
                return vectorBone[ getBoneId( index ) ];
            }

    };

    typedef std::vector< osg::ref_ptr< MeshData > > MeshesVector;

    // -- MeshData I/O --

    /**
     * Name of file with preprocessed meshes.
     */
    OSGCAL_EXPORT std::string meshesCacheFileName( const std::string& cfgFileName );

    OSGCAL_EXPORT void loadMeshes( const std::string&  fileName,
                                   const CalCoreModel* calCoreModel,
                                   MeshesVector& meshes )
        throw (std::runtime_error);

    OSGCAL_EXPORT void saveMeshes( const CalCoreModel* calCoreModel,
                                   const MeshesVector& meshes,
                                   const std::string&  fileName )
        throw (std::runtime_error);

    OSGCAL_EXPORT void loadMeshes( CalCoreModel* calCoreModel,
                                   MeshesVector& meshes )
        throw (std::runtime_error);
    

    // -- CalCoreModel I/O --

    OSGCAL_EXPORT CalCoreModel* loadCoreModel( const std::string& cfgFileName,
                                               float& scale,
                                               bool ignoreMeshes = false )
        throw (std::runtime_error);


    // -- NV_half_float half<=>float conversion --

    /** Converts float in uint32 format to a a half in uint16 format
     */
    inline GLushort floatToHalfI(GLuint i)
    {
        register int s =  (i >> 16) & 0x00008000;
        register int e = ((i >> 23) & 0x000000ff) - (127 - 15);
        register int m =   i        & 0x007fffff;
        
        if (e <= 0)
        {
            if (e < -10)
            {
                return 0;
            }
            m = (m | 0x00800000) >> (1 - e);
        
            return s | (m >> 13);
        }
        else if (e == 0xff - (127 - 15))
        {
            if (m == 0) // Inf
            {
                return s | 0x7c00;
            } 
            else    // NAN
            {
                m >>= 13;
                return s | 0x7c00 | m | (m == 0);
            }
        }
        else
        {
            if (e > 30) // Overflow
            {
                return s | 0x7c00;
            }
        
            return s | (e << 10) | (m >> 13);
        }
    }
        
    /** Convert a float32 to a float16 (NV_half_float)
        Courtesy of OpenEXR
    */
    inline GLushort floatToHalf(float i)
    {
        union { float f; GLuint i; } v;
        v.f = i;
        return floatToHalfI(v.i);
    }
 
    /** Converts a half in uint16 format to a float
        in uint32 format
    */
    inline GLuint halfToFloatI(GLushort y)
    {
        register GLuint s = (y >> 15) & 0x00000001;
        register GLuint e = (y >> 10) & 0x0000001f;
        register GLuint m =  y        & 0x000003ff;
        
        if (e == 0)
        {
            if (m == 0) // Plus or minus zero
            {
                return s << 31;
            }
            else // Denormalized number -- renormalize it
            {
                while (!(m & 0x00000400))
                {
                    m <<= 1;
                    e -=  1;
                }
        
                e += 1;
                m &= ~0x00000400;
            }
        }
        else if (e == 31)
        {
            if (m == 0) // Inf
            {
                return (s << 31) | 0x7f800000;
            }
            else // NaN
            {
                return (s << 31) | 0x7f800000 | (m << 13);
            }
        }
        
        e = e + (127 - 15);
        m = m << 13;
        
        return (s << 31) | (e << 23) | m;
    }

    /**
     * Convert a float16 (NV_half_float) to a float32
     * Courtesy of OpenEXR
     */
    inline float halfToFloat(GLushort y)
    {
        union { float f; GLuint i; } v;
        v.i = halfToFloatI(y);
        return v.f;
    }

}; // namespace osgCal

#endif
