/* -*- c++ -*-
    Copyright (C) 2007 Vladimir Shabanov <vshabanoff@gmail.com>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
#ifndef __OSGCAL__STATE_SET_CACHE_H__
#define __OSGCAL__STATE_SET_CACHE_H__

#include <map>

#include <osg/Texture2D>
#include <osg/Referenced>
#include <osg/Material>
#include <osg/Fog>
#include <osgCal/Export>
#include <osgCal/Material>
#include <osgCal/MeshLoader>
#include <osgCal/ShadersCache>

namespace osgCal
{
    template < typename T >
    struct ref_ptr_less : std::binary_function< osg::ref_ptr< T >, osg::ref_ptr< T >, bool >
    {
            bool operator () ( const osg::ref_ptr< T >& a,
                               const osg::ref_ptr< T >& b )
            {
                if ( a.get() == b.get() )
                {
                    return false;
                }
                else
                {
                    return *a.get() < *b.get();
                }
            }
    };

    template < typename T >
    struct ref_ptr_less : std::binary_function< osg::ref_ptr< T >, osg::ref_ptr< T >, bool >
    {
            bool operator () ( const osg::ref_ptr< T >& a,
                               const osg::ref_ptr< T >& b )
            {
                if ( a.get() == b.get() )
                {
                    return false;
                }
                else
                {
                    return *a.get() < *b.get();
                }
            }
    };
    
    /**
     * To maximize state sharing we use separate caches for
     * osg::Material, osg::Texture2D, osg::StateSet (SoftwareMaterial,
     * for software meshes),
     * osg::Program and osg::StateSet (Material, with shaders).
     *
     * Here is an internal cache hierarchy (the keys are shown in brakets):
     *
     * HardwareMeshStateSetCache[Material]
     *  |- SoftwareMeshStateSetCache[SoftwareMaterial]
     *  |- -|- TexturesCache[TextureDesc]
     *  |   \- MaterialsCache[OsgMaterial]
     *  \- ShadersCache[ShaderFlags]
     */
    class MaterialsCache : public osg::Referenced
    {
        public:
            osg::Material* get( const OsgMaterial* md );

        private:
            typedef std::map< osg::ref_ptr< const OsgMaterial >,
                              osg::Material*,
                              ref_ptr_less< const OsgMaterial > > Map;
            Map cache;

            osg::Material* createMaterial( const OsgMaterial& desc );
    };

    class TexturesCache : public osg::Referenced
    {
        public:
            osg::Texture2D* get( const TextureDesc& td );

        private:
            typedef std::map< TextureDesc, osg::Texture2D* > Map;
            Map cache;
            
            osg::Texture2D* createTexture( const TextureDesc& fileName )
                throw (std::runtime_error);
    };

    class SwMeshStateSetCache : public osg::Referenced
    {
        public:
            SwMeshStateSetCache( MaterialsCache* mc,
                                 TexturesCache*  tc );
            
            osg::StateSet* get( const SoftwareMaterial* swsd );

        private:
            typedef std::map< osg::ref_ptr< const SoftwareMaterial >,
                              osg::StateSet*,
                              ref_ptr_less< const SoftwareMaterial >
                              > Map;

            Map cache;
            osg::ref_ptr< MaterialsCache > materialsCache;
            osg::ref_ptr< TexturesCache >  texturesCache;

            osg::StateSet* createSwMeshStateSet( const SoftwareMaterial& swsd );
    };

    class HwMeshStateSetCache : public osg::Referenced
    {
        public:
            HwMeshStateSetCache( SwMeshStateSetCache* swssc,
                                 TexturesCache*       tc,
                                 ShadersCache*        sc );
            
            osg::StateSet* get( const Material* swsd,
                                int             bonesCount,
                                bool            useDepthFirstMesh );

            int flags;

        private:
            // map from < state desc, < bones count, useDepthFirstMesh > >
            typedef std::map< std::pair< osg::ref_ptr< Material >, std::pair< int, bool > >,
                              osg::StateSet* > Map;

            Map cache;
            osg::ref_ptr< SwMeshStateSetCache > swMeshStateSetCache;
            osg::ref_ptr< TexturesCache >       texturesCache;
            osg::ref_ptr< ShadersCache >        shadersCache;

            osg::StateSet* createHwMeshStateSet(
                const std::pair< Material, std::pair< int, bool > >& matAndBones );
    };

    class DepthMeshStateSetCache : public osg::Referenced
    {
        public:
            DepthMeshStateSetCache( ShadersCache* sc )
                : flags( 0 )
                , shadersCache( sc )                  
            {}
            osg::StateSet* get( const Material& material,
                                int             bonesCount );

            int flags;

        private:
            // map from < bone count, sides count > to stateset
            typedef std::map< std::pair< int, int >, osg::StateSet* > Map;

            Map cache;
            osg::ref_ptr< ShadersCache >        shadersCache;

            osg::StateSet* createDepthMeshStateSet( const std::pair< int, int >& boneAndSidesCount );
    };

    class StateSetCache : public osg::Referenced
    {
        public:

            StateSetCache();

            osg::ref_ptr< SwMeshStateSetCache >     swMeshStateSetCache;
            osg::ref_ptr< HwMeshStateSetCache >     hwMeshStateSetCache;
            osg::ref_ptr< DepthMeshStateSetCache >  depthMeshStateSetCache;

            /**
             * Return global state set cache instance. Instance is
             * keeped inside osg::observer_ptr so it will be removed
             * when last reference to StateSetCache is removed. Also
             * instance does not exists until first instance() call.
             */
            static StateSetCache* instance();
            
    };

}; // namespace osgCal

#endif
